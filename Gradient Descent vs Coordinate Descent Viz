import React, { useState, useEffect, useRef } from 'react';
import { Play, Pause, RotateCcw } from 'lucide-react';

const GradientDescentViz = () => {
  const canvasRef = useRef(null);
  const [isRunning, setIsRunning] = useState(false);
  const [algorithm, setAlgorithm] = useState('gradient');
  const [stepCount, setStepCount] = useState(0);
  const [learningRate, setLearningRate] = useState(0.1);
  
  // State for both algorithms
  const [gdPoint, setGdPoint] = useState({ x: -2, y: 2 });
  const [cdPoint, setCdPoint] = useState({ x: -2, y: 2 });
  const [gdPath, setGdPath] = useState([]);
  const [cdPath, setCdPath] = useState([]);
  const [cdAxis, setCdAxis] = useState(0); // 0 for x, 1 for y
  
  // Cost function: elliptical paraboloid (elongated bowl)
  const costFunction = (x, y) => {
    return 2 * x * x + 0.5 * y * y;
  };
  
  // Gradient of the cost function
  const gradient = (x, y) => {
    return {
      dx: 4 * x,
      dy: y
    };
  };
  
  const reset = () => {
    const startX = -2;
    const startY = 2;
    setGdPoint({ x: startX, y: startY });
    setCdPoint({ x: startX, y: startY });
    setGdPath([{ x: startX, y: startY }]);
    setCdPath([{ x: startX, y: startY }]);
    setStepCount(0);
    setCdAxis(0);
    setIsRunning(false);
  };
  
  useEffect(() => {
    reset();
  }, []);
  
  useEffect(() => {
    if (!isRunning) return;
    
    const interval = setInterval(() => {
      if (algorithm === 'gradient') {
        setGdPoint(prev => {
          const grad = gradient(prev.x, prev.y);
          const newPoint = {
            x: prev.x - learningRate * grad.dx,
            y: prev.y - learningRate * grad.dy
          };
          setGdPath(path => [...path, newPoint]);
          setStepCount(c => c + 1);
          
          // Stop if converged
          if (Math.abs(grad.dx) < 0.01 && Math.abs(grad.dy) < 0.01) {
            setIsRunning(false);
          }
          
          return newPoint;
        });
      } else {
        setCdPoint(prev => {
          let newPoint;
          if (cdAxis === 0) {
            // Update x, keep y fixed
            const grad = gradient(prev.x, prev.y);
            newPoint = {
              x: prev.x - learningRate * grad.dx,
              y: prev.y
            };
          } else {
            // Update y, keep x fixed
            const grad = gradient(prev.x, prev.y);
            newPoint = {
              x: prev.x,
              y: prev.y - learningRate * grad.dy
            };
          }
          
          setCdPath(path => [...path, newPoint]);
          setCdAxis(axis => 1 - axis); // Toggle between 0 and 1
          setStepCount(c => c + 1);
          
          // Stop if converged
          const grad = gradient(newPoint.x, newPoint.y);
          if (Math.abs(grad.dx) < 0.01 && Math.abs(grad.dy) < 0.01) {
            setIsRunning(false);
          }
          
          return newPoint;
        });
      }
    }, 300);
    
    return () => clearInterval(interval);
  }, [isRunning, algorithm, learningRate, cdAxis]);
  
  useEffect(() => {
    const canvas = canvasRef.current;
    if (!canvas) return;
    
    const ctx = canvas.getContext('2d');
    const width = canvas.width;
    const height = canvas.height;
    
    // Clear canvas
    ctx.fillStyle = '#1a1a2e';
    ctx.fillRect(0, 0, width, height);
    
    // Transform coordinates: map [-3, 3] to canvas
    const scale = 60;
    const originX = width / 2;
    const originY = height / 2;
    
    const toCanvasX = (x) => originX + x * scale;
    const toCanvasY = (y) => originY - y * scale;
    
    // Draw contour lines
    ctx.strokeStyle = '#2a2a4e';
    ctx.lineWidth = 1;
    
    const levels = [0.5, 1, 2, 4, 8, 12, 16];
    levels.forEach(level => {
      ctx.beginPath();
      for (let angle = 0; angle <= Math.PI * 2; angle += 0.01) {
        // Ellipse equation: 2x² + 0.5y² = level
        // x = sqrt(level/2) * cos(θ), y = sqrt(level/0.5) * sin(θ)
        const x = Math.sqrt(level / 2) * Math.cos(angle);
        const y = Math.sqrt(level / 0.5) * Math.sin(angle);
        
        if (angle === 0) {
          ctx.moveTo(toCanvasX(x), toCanvasY(y));
        } else {
          ctx.lineTo(toCanvasX(x), toCanvasY(y));
        }
      }
      ctx.closePath();
      ctx.stroke();
    });
    
    // Draw axes
    ctx.strokeStyle = '#4a4a6e';
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(0, originY);
    ctx.lineTo(width, originY);
    ctx.moveTo(originX, 0);
    ctx.lineTo(originX, height);
    ctx.stroke();
    
    // Draw optimum point
    ctx.fillStyle = '#4ade80';
    ctx.beginPath();
    ctx.arc(toCanvasX(0), toCanvasY(0), 6, 0, Math.PI * 2);
    ctx.fill();
    
    // Draw paths and current points
    const drawPath = (path, color, label) => {
      if (path.length < 2) return;
      
      // Draw path
      ctx.strokeStyle = color;
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(toCanvasX(path[0].x), toCanvasY(path[0].y));
      for (let i = 1; i < path.length; i++) {
        ctx.lineTo(toCanvasX(path[i].x), toCanvasY(path[i].y));
      }
      ctx.stroke();
      
      // Draw points along path
      ctx.fillStyle = color;
      path.forEach((point, i) => {
        if (i % 2 === 0) { // Draw every other point to reduce clutter
          ctx.beginPath();
          ctx.arc(toCanvasX(point.x), toCanvasY(point.y), 3, 0, Math.PI * 2);
          ctx.fill();
        }
      });
      
      // Draw current point larger
      const current = path[path.length - 1];
      ctx.beginPath();
      ctx.arc(toCanvasX(current.x), toCanvasY(current.y), 7, 0, Math.PI * 2);
      ctx.fill();
      
      // Label
      ctx.fillStyle = '#ffffff';
      ctx.font = '14px monospace';
      ctx.fillText(label, toCanvasX(current.x) + 12, toCanvasY(current.y) - 12);
    };
    
    if (algorithm === 'gradient' && gdPath.length > 0) {
      drawPath(gdPath, '#3b82f6', 'GD');
    }
    
    if (algorithm === 'coordinate' && cdPath.length > 0) {
      drawPath(cdPath, '#f59e0b', 'CD');
    }
    
  }, [gdPoint, cdPoint, gdPath, cdPath, algorithm]);
  
  return (
    <div className="w-full max-w-4xl mx-auto p-6 bg-gray-900 text-white rounded-lg">
      <h2 className="text-2xl font-bold mb-4">Gradient Descent vs Coordinate Descent</h2>
      
      <div className="grid grid-cols-1 md:grid-cols-2 gap-4 mb-6">
        <div className="bg-gray-800 p-4 rounded">
          <h3 className="font-semibold mb-2 text-blue-400">Gradient Descent</h3>
          <p className="text-sm">Moves in the direction of steepest descent, updating all parameters simultaneously.</p>
        </div>
        <div className="bg-gray-800 p-4 rounded">
          <h3 className="font-semibold mb-2 text-amber-400">Coordinate Descent</h3>
          <p className="text-sm">Updates one parameter at a time, alternating between x and y axes.</p>
        </div>
      </div>
      
      <canvas 
        ref={canvasRef} 
        width={600} 
        height={500}
        className="w-full border border-gray-700 rounded mb-4"
      />
      
      <div className="space-y-4">
        <div className="flex items-center gap-4">
          <label className="font-semibold">Algorithm:</label>
          <button
            onClick={() => { setAlgorithm('gradient'); reset(); }}
            className={`px-4 py-2 rounded ${algorithm === 'gradient' ? 'bg-blue-600' : 'bg-gray-700'}`}
          >
            Gradient Descent
          </button>
          <button
            onClick={() => { setAlgorithm('coordinate'); reset(); }}
            className={`px-4 py-2 rounded ${algorithm === 'coordinate' ? 'bg-amber-600' : 'bg-gray-700'}`}
          >
            Coordinate Descent
          </button>
        </div>
        
        <div className="flex items-center gap-4">
          <label className="font-semibold">Learning Rate: {learningRate.toFixed(2)}</label>
          <input
            type="range"
            min="0.01"
            max="0.3"
            step="0.01"
            value={learningRate}
            onChange={(e) => setLearningRate(parseFloat(e.target.value))}
            className="flex-1"
          />
        </div>
        
        <div className="flex items-center gap-4">
          <button
            onClick={() => setIsRunning(!isRunning)}
            className="flex items-center gap-2 px-6 py-2 bg-green-600 hover:bg-green-700 rounded"
          >
            {isRunning ? <Pause size={20} /> : <Play size={20} />}
            {isRunning ? 'Pause' : 'Start'}
          </button>
          <button
            onClick={reset}
            className="flex items-center gap-2 px-6 py-2 bg-gray-700 hover:bg-gray-600 rounded"
          >
            <RotateCcw size={20} />
            Reset
          </button>
          <span className="ml-auto font-semibold">Steps: {stepCount}</span>
        </div>
      </div>
      
      <div className="mt-6 p-4 bg-gray-800 rounded">
        <h3 className="font-semibold mb-2">Key Insights:</h3>
        <ul className="text-sm space-y-2">
          <li>• <strong>Gradient Descent</strong> moves diagonally toward the minimum, taking a more direct path</li>
          <li>• <strong>Coordinate Descent</strong> zigzags because it can only move along one axis at a time</li>
          <li>• For elongated error surfaces (like this ellipse), GD is much more efficient</li>
          <li>• The contour lines show equal cost values - closer spacing means steeper terrain</li>
        </ul>
      </div>
    </div>
  );
};

export default GradientDescentViz;
